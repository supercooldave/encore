module Decode

import Data.Maybee hiding(map)
import Data.Either hiding(or_else)
import Collections.Mutable.HashMap
import JSON.Parser
import JSON.Raw

{- The design of this module follows Elm's -}

-- TODO: move to another module related to Exceptions 
-- But inside Encore, not Sahand's
typedef Result[t] = Either[String,t]

fun good[t](x : t) : Result[t]
  Right[String,t](x)
end

fun bad[t](s : String) : Result[t]
  Left[String,t](s)
end


{- decode :: (Decoder[t], String) -> Result[String,t]
   first parses the string into a JSON value
   and then runs a decoder on the result.
   Fails if either the parser or the decoder fails

     decode(new IntDecoder(), "4")      == Right 4
     decode(new IntDecoder(), "3 + 2")  == Left ...
     
  TODO: find an easier way of creating decoders
-}
fun decode[t](decoder : Decoder[t], str: String) : Result[t]
  match parse(str) with
    case Nothing => bad[t]("JSON parser failed.")
    case Just(raw) => decoder.decode(raw)
  end
end


-- A trait for JSON decoders
read trait Decoder[t]
  require def decode(raw: Value) : Result[t]
end

-- the decoders

{-  Decode JSON String into a String 

    decode(new StringDecoder(), "true")              == Left ...
    decode(new StringDecoder(), "42")                == Left ...
    decode(new StringDecoder(), "3.14")              == Left ...
    decode(new StringDecoder(), "\"hello\"")         == Right "hello"
    decode(new StringDecoder(), "{ \"hello\": 42 }") == Left ...
-}
class StringDecoder : Decoder[String]
  def decode(raw: Value) : Result[String]
    match raw with
      case RawString(str) => good(str) 
      case _ => bad[String]("Wrong format for JSON string")
    end
  end 
end

{- Decode a JSON number into an int

    decode(new IntDecoder(), "true")              == Left ...
    decode(new IntDecoder(), "42")                == Right 42
    decode(new IntDecoder(), "3.14")              == Left ...
    decode(new IntDecoder(), "\"hello\"")         == Left ...
    decode(new IntDecoder(), "{ \"hello\": 42 }") == Left ...
-}
class IntDecoder : Decoder[int]
  def decode(raw: Value) : Result[int]
    match raw with
      case RawNumber(num) =>
        match num.to_int() with
          case Just(i) => good(i)
          case Nothing => bad[int]("Wrong format for JSON int")
        end
      end
      case _ => bad[int]("Wrong format for JSON int")
    end
  end 
end


{- Decode a JSON boolean into a bool

    decode(new BoolDecoder(), "true")              == Right True
    decode(new BoolDecoder(), "42")                == Left ...
    decode(new BoolDecoder(), "3.14")              == Left ...
    decode(new BoolDecoder(), "\"hello\"")         == Left ...
    decode(new BoolDecoder(), "{ \"hello\": 42 }") == Left ...
-}
class BoolDecoder : Decoder[bool]
  def decode(raw: Value) : Result[bool]
    match raw with
      case RawBool(i) => good(i)
      case _ => bad[bool]("Wrong format for JSON bool")
    end
  end 
end

{- Decode a JSON number into a real

    decode(new RealDecoder(), "true")              == Left ..
    decode(new RealDecoder(), "42")                == Right 42
    decode(new RealDecoder(), "3.14")              == Right 3.14
    decode(new RealDecoder(), "\"hello\"")         == Left ...
    decode(new RealDecoder(), "{ \"hello\": 42 }") == Left ...
-}
class RealDecoder : Decoder[real]
  def decode(raw: Value) : Result[real]
    match raw with
      case RawNumber(num) =>
        match num.to_real() with
          case Just(i) => good(i)
          case Nothing => bad[real]("Wrong format for JSON real")
        end
      end
      case _ => bad[real]("Wrong format for JSON real")
    end
  end 
end

{- Decode a `null` value into some value.

    decode(new NullDecoder[bool](False), "null") == Right False
    decode(new NullDecoder[int](42), "null") == Right 42
    decode(new NullDecoder[int](42), "42") == Left ...
    decode(new NullDecoder[int](42), "false") == Left ...

-}
class NullDecoder[t] : Decoder[t](default)
  val default : t
  
  def init(default : t) : unit
    this.default = default
  end
  
  def decode(raw: Value) : Result[t]
    match raw with
      case Null() => good(this.default)
      case _ => bad[t]("Does not match JSON null")
    end
  end  
end


{- Decode a nullable JSON value into an Elm value.

    decode(new Nullable[int](new IntDecoder()), "42")   == Right (Just 42)
    decode(new Nullable[int](new IntDecoder()), "null") == Right Nothing
    decode(new Nullable[int](new IntDecoder()), "true") == Left ...
-}
class Nullable[t] : Decoder[Maybe[t]](dec)
  val dec : Decoder[Maybe[t]]
  
  def init(sub : Decoder[t]) : unit
    this.dec = one_of([ new NullDecoder[Maybe[t]](Nothing) : Decoder[Maybe[t]], 
                        map(fun (x : t) => Just(x), sub)]) 
  end

  def decode(raw: Value) : Result[Maybe[t]]
    this.dec.decode(raw)
  end
end


{- ignore the JSON and fail -}
class Fail[t] : Decoder[t](msg)
  val msg : String
  
  def init(msg : String) : unit
    this.msg = msg
  end

  def decode(raw: Value) : Result[t]
    bad[t](this.msg)
  end
end



{- Ignore the JSON and produce a certain value.  
    decode(new Succeed[int](42), "true")    == Right 42
    decode(new Succeed[int](42), "[1,2,3]") == Right 42
    decode(new Succeed[int](42), "Hello")   == Left ... -- this is not a valid JSON string
-}
class Succeed[t] : Decoder[t](default)
  val default : t
  
  def init(default : t) : unit
    this.default = default
  end
  
  def decode(raw: Value) : Result[t]
    good(this.default)
  end  
end

class DecoderHolder[t] : Decoder[t](dec)
  val dec : Value -> Result[t]
  
  def init(dec : Value -> Result[t]) : unit
    this.dec = dec
  end

  def decode(raw: Value) : Result[t]
    this.dec(raw)
  end
end



{- Extract a particular field from a JSON object

    decode(new Field[int]("x", new IntDecoder()), "{ \"x\": 3 }")                == Right 3
    decode(new Field[int]("x", new IntDecoder()), "{ \"x\": 3, \"y\": 4 }")      == Right 3
    decode(new Field[int]("x", new IntDecoder()), "{ \"x\": true }")             == Left ...
    decode(new Field[int]("x", new IntDecoder()), "{ \"y\": 4 }")                == Left ...
    decode(new Field[String]("name", new StringDecoder()), "{ \"name\": \"tom\" }") == Right "tom"
-}
class Field[t] : Decoder[t](name, sub)
  val name : String
  val sub : Decoder[t]
  
  def init(name : String, sub : Decoder[t]) : unit
    this.name = name
    this.sub = sub
  end
  
  def decode(raw: Value) : Result[t]
    match raw with
      case RawObject(hash) => 
        match hash.get_value(this.name) with
          case Just(value) => this.sub.decode(value)
          case Nothing => bad[t]("Expected a JSON object with field '".concatenate(this.name).concatenate("'"))
        end
      end
      case _ => bad[t]("Expected a JSON object")
    end
  end
end


{- Extract a particular path from a JSON object

    json = "{ "person": { "name": "tom", "age": 42 } }"

    decodeString (at ["person", "name"] string) json  == Ok "tom"
    decodeString (at ["person", "age" ] int   ) json  == Ok "42

This is really just a shorthand for saying things like:

    field "person" (field "name" string) == at ["person","name"] string
-}
class At[t] : Decoder[t](sub, path)
  val path : [String]
  val sub : Decoder[t]
  
  def init(path : [String], sub : Decoder[t]) : unit
    this.path = path
    this.sub = sub
  end

  def decode(raw : Value) : Result[t]
    var node = raw
    var decoder = this.sub
    for name <- this.path do
      match dig(name, node) with
        case Just(value) => 
          node = value 
          bad[t]("nothing") -- value ignored, used to help type checker
        end
        case Nothing => return bad[t]("Expect path ".concatenate(".".join(this.path)))
      end
    end    
    decoder.decode(node)
  where
    fun dig(name : String, node : Value) : Maybe[Value]
      match node with
        case RawObject(hash) => hash.get_value(name)
        case _ => Nothing
      end
    end
  end
end


{- extract given index of JSON array
TODO: fix comment
    json = """[ "alice", "bob", "chuck" ]"""

    decodeString (index 0 string) json  == Ok "alice"
    decodeString (index 1 string) json  == Ok "bob"
    decodeString (index 2 string) json  == Ok "chuck"
    decodeString (index 3 string) json  == Err ...
-}
class Index[t] : Decoder[t](index, dec)
  val index : int
  val dec : Decoder[t]
  
  def init(index : int, dec : Decoder[t]) : unit
    this.index = index
    this.dec = dec
  end
  
  def decode(raw : Value) : Result[t]
    match raw with
      case RawArray(arr) => 
        if this.index >= 0 && this.index < |arr| then
          this.dec.decode(arr(this.index))
        else
          bad[t]("Index out of bounds")
        end
      end
      case _ => bad[t]("Expected JSON array")
    end
  end
end


{- Decode a JSON array .

    decode(new ArrayDecoder[int](new IntDecoder()), "[1,2,3]")      == Right [1,2,3]
    decode(new ArrayDecoder[int](new IntDecoder()), "[true,false]") == Right [true,false] 
-}
class ArrayDecoder[t] : Decoder[[t]](dec)
  val dec : Decoder[t]
  
  def init(dec : Decoder[t]) : unit
    this.dec = dec
  end
  
  def decode(raw: Value) : Result[[t]]
    match raw with
      case RawArray(arr) => 
        val res = new [t](|arr|)
        for i <- [0 .. |arr| - 1] do
          match this.dec.decode(arr(i)) with
            case Right(v) => 
              res(i) = v
              bad[[t]]("Nothing") -- a hack to please type system
            end
            case Left(err) => return bad[[t]](err)
          end
        end
        good(res)
      end
      case _ => bad[[t]]("Expected JSON array")
    end
  end
end



{- Decode a JSON object into a hash table

    decode(new Dict[t](new IntDecoder()), "{ \"alice\": 42, \"bob\": 99 }")
      == HashMap["alice" => 42, "bob" => 99]
-}
class Dict[t] : Decoder[HashMap[t]](dec)
  val dec : Decoder[t]
  
  def init(dec : Decoder[t]) : unit
    this.dec = dec
  end
  
  def decode(raw : Value) : Result[HashMap[t]]
    match raw with
      case RawObject(hash) => 
        val iter = hash.iterator()
        val new_map = new HashMap[t]()
        while iter.has_next() do
          val x = unjust(iter.next())
          match this.dec.decode(x.value) with
            case Right(y) => 
              new_map.set(x.key, y)
              bad[HashMap[t]]("Nothing")  -- HACK to please type checker
            end
            case Left(err) => return bad[HashMap[t]](err)
          end
        end

        return good(new_map)
      end
      case _ => bad[HashMap[t]]("Expected JSON object")
    end
  end
end



{- Decode a JSON object into an array of pairs.

    decode(keyValuePairs(new IntDecoder()), "{ \"alice\": 42, \"bob\": 99 }")
      == [("alice", 42), ("bob", 99)]
-}
keyValuePairs : Decoder a -> Decoder (List (String, a))
keyValuePairs =
  Native.Json.decodeKeyValuePairs

{- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



-- utility functions

{-| Try a bunch of different decoders. This can be useful if the JSON may come
in a couple different formats. For example, say you want to read an array of
numbers, but some of them are `null`.

    import String

    badInt : Decoder Int
    badInt =
      oneOf [ int, null 0 ]

    -- decodeString (list badInt) "[1,2,null,4]" == Ok [1,2,0,4]

Why would someone generate JSON like this? Questions like this are not good
for your health. The point is that you can use `oneOf` to handle situations
like this!

You could also use `oneOf` to help version your data. Try the latest format,
then a few older ones that you still support. You could use `andThen` to be
even more particular if you wanted.
-}
-}

fun one_of[t](decs : [Decoder[t]]) : Decoder[t]
  one_of_helper(decs,0)
where
  fun one_of_helper(decs : [Decoder[t]], index : int) : Decoder[t]
    if index < |decs| then
      or_else(decs(index), one_of_helper(decs, index + 1))
    else
      new Fail[t]("No valid choice")
    end
  end
end

-- TODO: comment (basically, the core of one_of)
fun or_else[t](dec1 : Decoder[t], dec2 : Decoder[t]) : Decoder[t]
  val next = fun (str : Value)
               val one = dec1.decode(str)
               if is_right(one) then
                 one
               else
                 dec2.decode(str)
               end
             end
  new DecoderHolder[t](next)
end

{-
{-| Helpful for dealing with optional fields. Here are a few slightly different
examples:

    json = """{ "name": "tom", "age": 42 }"""

    decodeString (maybe (field "age"    int  )) json == Ok (Just 42)
    decodeString (maybe (field "name"   int  )) json == Ok Nothing
    decodeString (maybe (field "height" float)) json == Ok Nothing

    decodeString (field "age"    (maybe int  )) json == Ok (Just 42)
    decodeString (field "name"   (maybe int  )) json == Ok Nothing
    decodeString (field "height" (maybe float)) json == Err ...

Notice the last example! It is saying we *must* have a field named `height` and
the content *may* be a float. There is no `height` field, so the decoder fails.

Point is, `maybe` will make exactly what it contains conditional. For optional
fields, this means you probably want it *outside* a use of `field` or `at`.
-}
maybe : Decoder a -> Decoder (Maybe a)
maybe decoder =
  Native.Json.decodeContainer "maybe" decoder


{-| Do not do anything with a JSON value, just bring it into Elm as a `Value`.
This can be useful if you have particularly crazy data that you would like to
deal with later. Or if you are going to send it out a port and do not care
about its structure.

Could use RAW!!
-}
value : Decoder Value
value =
  Native.Json.decodePrimitive "value"

-}

-- mapping functions
fun map[s,t](f : s -> t, dec : Decoder[s]) : Decoder[t]
  val next = fun (raw : Value) : Result[t] => dec.decode(raw).map(f) 
  new DecoderHolder[t](next)
end

{-
--- ELM STUFF
--- ELM STUFF
--- ELM STUFF
--- ELM STUFF
--- ELM STUFF
--- ELM STUFF




-- MAPPING


{-| Transform a decoder. Maybe you just want to know the length of a string:

    import String

    stringLength : Decoder Int
    stringLength =
      map String.length string

It is often helpful to use `map` with `oneOf`, like when defining `nullable`:

    nullable : Decoder a -> Decoder (Maybe a)
    nullable decoder =
      oneOf
        [ null Nothing
        , map Just decoder
        ]
-}
map : (a -> value) -> Decoder a -> Decoder value
map =
    Native.Json.map1


{-| Try two decoders and then combine the result. We can use this to decode
objects with many fields:

    type alias Point = { x : Float, y : Float }

    point : Decoder Point
    point =
      map2 Point
        (field "x" float)
        (field "y" float)

    -- decodeString point """{ "x": 3, "y": 4 }""" == Ok { x = 3, y = 4 }

It tries each individual decoder and puts the result together with the `Point`
constructor.
-}
map2 : (a -> b -> value) -> Decoder a -> Decoder b -> Decoder value
map2 =
    Native.Json.map2


{-| Try three decoders and then combine the result. We can use this to decode
objects with many fields:

    type alias Person = { name : String, age : Int, height : Float }

    person : Decoder Person
    person =
      map3 Person
        (at ["name"] string)
        (at ["info","age"] int)
        (at ["info","height"] float)

    -- json = """{ "name": "tom", "info": { "age": 42, "height": 1.8 } }"""
    -- decodeString person json == Ok { name = "tom", age = 42, height = 1.8 }

Like `map2` it tries each decoder in order and then give the results to the
`Person` constructor. That can be any function though!
-}
map3 : (a -> b -> c -> value) -> Decoder a -> Decoder b -> Decoder c -> Decoder value
map3 =
    Native.Json.map3


{-|-}
map4 : (a -> b -> c -> d -> value) -> Decoder a -> Decoder b -> Decoder c -> Decoder d -> Decoder value
map4 =
    Native.Json.map4


{-|-}
map5 : (a -> b -> c -> d -> e -> value) -> Decoder a -> Decoder b -> Decoder c -> Decoder d -> Decoder e -> Decoder value
map5 =
    Native.Json.map5


{-|-}
map6 : (a -> b -> c -> d -> e -> f -> value) -> Decoder a -> Decoder b -> Decoder c -> Decoder d -> Decoder e -> Decoder f -> Decoder value
map6 =
    Native.Json.map6


{-|-}
map7 : (a -> b -> c -> d -> e -> f -> g -> value) -> Decoder a -> Decoder b -> Decoder c -> Decoder d -> Decoder e -> Decoder f -> Decoder g -> Decoder value
map7 =
    Native.Json.map7


{-|-}
map8 : (a -> b -> c -> d -> e -> f -> g -> h -> value) -> Decoder a -> Decoder b -> Decoder c -> Decoder d -> Decoder e -> Decoder f -> Decoder g -> Decoder h -> Decoder value
map8 =
    Native.Json.map8








-- FANCY PRIMITIVES

{-| Create decoders that depend on previous results. If you are creating
versioned data, you might do something like this:

    info : Decoder Info
    info =
      field "version" int
        |> andThen infoHelp

    infoHelp : Int -> Decoder Info
    infoHelp version =
      case version of
        4 ->
          infoDecoder4

        3 ->
          infoDecoder3

        _ ->
          fail <|
            "Trying to decode info, but version "
            ++ toString version ++ " is not supported."

    -- infoDecoder4 : Decoder Info
    -- infoDecoder3 : Decoder Info
-}
andThen : (a -> Decoder b) -> Decoder a -> Decoder b
andThen =
  Native.Json.andThen


{-| Sometimes you have JSON with recursive structure, like nested comments.
You can use `lazy` to make sure your decoder unrolls lazily.

    type alias Comment =
      { message : String
      , responses : Responses
      }

    type Responses = Responses (List Comment)

    comment : Decoder Comment
    comment =
      map2 Comment
        (field "message" string)
        (field "responses" (map Responses (list (lazy (\_ -> comment)))))

If we had said `list comment` instead, we would start expanding the value
infinitely. What is a `comment`? It is a decoder for objects where the
`responses` field contains comments. What is a `comment` though? Etc.

By using `list (lazy (\_ -> comment))` we make sure the decoder only expands
to be as deep as the JSON we are given. You can read more about recursive data
structures [here][].

[here]: https://github.com/elm-lang/elm-compiler/blob/master/hints/recursive-alias.md
-}
lazy : (() -> Decoder a) -> Decoder a
lazy thunk =
  andThen thunk (succeed ())

-}



